## 前言
自从micro-app开源后，很多小伙伴都非常感兴趣，问我具体的实现方式，其实微前端的实现方式大同小异，基本核心在于加载渲染。我会通过一个系列文章，介绍微前端的基本原理及核心功能，包括：加载渲染、JS沙箱、CSS隔离、数据通信，并实现一个简易的微前端框架。

通过这些文章，你可以了解微前端框架的具体原理和实现方式，这在你以后使用微前端或者自己写一套微前端框架时会有很大的帮助。如果这篇文章对你有帮助，欢迎点赞留言，也欢迎大家 "Star" [micro-app](https://github.com/micro-zoe/micro-app) 支持一下 谢谢！ \^_^

## 相关推荐
micro-app源码地址：https://github.com/micro-zoe/micro-app

## 整体架构
和micro-app一样，我们的简易微前端框架设计思路是像使用iframe一样简单，而又可以避免iframe存在的问题，其使用方式如下：

![](https://img13.360buyimg.com/imagetools/jfs/t1/181724/1/15979/23894/60ffedfcEa74486b6/9cfeb02f4347357a.png)

最终效果也有点类似，整个微前端应用都被封装在自定义标签micro-app中，渲染后效果如下图：

![](https://img11.360buyimg.com/imagetools/jfs/t1/187866/25/15336/129323/60ffc089E76d6416d/9fb1f6ee70499254.png)

所以我们整体架构思路为：**CustomElement + HTMLEntry**。

HTMLEntry就是以html文件作为入口地址进行渲染，入上图中的`http://localhost:3000/`就是一个html地址。

**概念图：**
![](https://img10.360buyimg.com/imagetools/jfs/t1/188133/39/15743/117766/61024cd2E5ed84b36/b816384088ba6ed1.png)

## 前置工作
在正式开始之前，我们需要搭建一个开发环境，创建一个代码仓库`simple-micro-app`。

**目录结构**
![](https://img11.360buyimg.com/imagetools/jfs/t1/196336/1/15327/76954/6102650dE1f9d7850/3fe44809e029d4d5.png)


代码仓库主要分为src主目录和examples案例目录，vue2为基座应用，react17为子应用，两个项目都是使用官方脚手架创建的，构建工具使用rollup。

在vue2项目中，配置`resolve.alias`，将simple-micro-app指向src目录的index.js。
```js
// vue.config.js
...
chainWebpack: config => {
    config.resolve.alias
      .set("simple-micro-app", path.join(__dirname, '../../src/index.js'))
  },
```
在react17的webpack-dev-server中配置静态资源支持跨域访问。
```js
// config/webpackDevServer.config.js
...
headers: {
  'Access-Control-Allow-Origin': '*',
},
```

## 正式开始
为了讲的更加明白，我们不会直接贴出已经完成的代码，而是从无到有，一步步实现整个过程，这样才能更加清晰，容易理解。

### 创建容器
微前端的渲染是将子应用的js、css等静态资源加载到基座应用中执行，所以基座应用和子应用本质是同一个页面。这不同于iframe，iframe则是创建一个新的窗口，由于每次加载都要初始化整个窗口信息，所以iframe的性能不高。

如同每个前端框架在渲染时都要指定一个根元素，微前端渲染时也需要指定一个根元素作为容器，这个根元素可以是一个div或其它元素。

这里我们使用的是通过customElements创建的自定义元素，因为它不仅提供一个元素容器，还自带了生命周期函数，我们可以在这些钩子函数中进行加载渲染等操作，从而简化步骤。

```js
// /src/element.js

// 自定义元素
class MyElement extends HTMLElement {
  // 声明需要监听的属性名，只有这些属性变化时才会触发attributeChangedCallback
  static get observedAttributes () {
    return ['name', 'url']
  }

  constructor() {
    super();
  }

  connectedCallback() {
    // 元素被插入到DOM时执行，此时去加载子应用的静态资源并渲染
    console.log('micro-app is connected')
  }

  disconnectedCallback () {
    // 元素从DOM中删除时执行，此时进行一些卸载操作
    console.log('micro-app has disconnected')
  }

  attributeChangedCallback (attr, oldVal, newVal) {
    // 元素属性发生变化时执行，可以获取name、url等属性的值
    console.log(`attribute ${attrName}: ${newVal}`)
  }
}

/**
 * 注册元素
 * 注册后，就可以像普通元素一样使用micro-app，当micro-app元素被插入或删除DOM时即可触发相应的生命周期函数。
 */
window.customElements.define('micro-app', MyElement)
```

`micro-app`元素可能存在重复定义的情况，所以我们加一层判断，并放入函数中。
```js
// /src/element.js

export function defineElement () {
  // 如果已经定义过，则忽略
  if (!window.customElements.get('micro-app')) {
    window.customElements.define('micro-app', MyElement)
  }
}
```

在`/src/index.js`中定义默认对象`SimpleMicroApp`，引入并执行`defineElement`函数。
```js
// /src/index.js

import { defineElement } from './element'

const SimpleMicroApp = {
  start () {
    defineElement()
  }
}

export default SimpleMicroApp
```

**引入simple-micro-app**
在vue2项目的main.js中引入simple-micro-app，执行start函数进行初始化。
```js
// vue2/src/main.js

import SimpleMicroApp from 'simple-micro-app'

SimpleMicroApp.start()
```

然后就可以在vue2项目中的任何位置使用micro-app标签。
```html
<!-- page1.vue -->
<template>
  <div>
    <micro-app name='app' url='http://localhost:3001/'></micro-app>
  </div>
</template>
```
插入micro-app标签后，就可以看到控制台打印的钩子信息。
![](https://img14.360buyimg.com/imagetools/jfs/t1/185099/11/16261/81332/610297a1Ede21e543/999043868783cbec.png)

以上我们就完成了容器元素的初始化，子应用的所有元素都会放入到这个容器中。接下来我们就需要完成子应用的静态资源加载及渲染。

### 加载资源
